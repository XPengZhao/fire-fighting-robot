# 跑马灯实验

STM32最简单的外设莫过于IO口的高低电平控制了，该教程将通过一个经典的跑马灯程序，带大家开启 STM32 之旅。

我们将通过代码控制 ALIENTEK MiniSTM32 开发板上的两个 LED：DS0 和 DS1 交替闪烁，实现类似跑马灯的效果。通过学习，你将了解到 STM32 的 IO 口作为输出使用的基本方法。

本章分为如下四个小节：

- STM32 IO 口简介
- 硬件设计
- 软件设计
- 仿真与下载

## 1. STM32 IO口简介

我们在讲解固件库之前会首先对重要[寄存器]进行一个讲解，这样是为了大家对寄存器有个初步的了解。大家学习固件库，并不需要记住每个寄存器的作用，而只是通过了解寄存器来对外设一些功能有个大致的了解，这样对以后的学习也很有帮助。

在固件库中，GPIO 端口操作对应的库函数函数以及相关定义在文件stm32f10x_gpio.h 和 stm32f10x_gpio.c 中。

### 1.1 IO口模式

首先 STM32 的 IO 口可以由**软件**配置成如下 8 种模式：

1. 输入浮空
2. 输入上拉
3. 输入下拉
4. 模拟输入
5. 开漏输出
6. 推挽输出
7. 推挽式复用功能
8. 开漏复用功能

每个 IO 口可以自由编程，但 IO 口寄存器必须要按 32 位字被访问。STM32 的很多 IO 口都是 5V 兼容的，这些 IO 口在与 5V 电平的外设连接的时候很有优势，具体哪些 IO 口是 5V 兼容的，可以从该芯片的数据手册管脚描述章节查到（I/O Level 标 FT 的就是 5V 电平兼容的）。

### 1.2 GPIO端口寄存器

STM32 的每个 IO 端口都有 7 个寄存器来控制。分别是：

- 两个32位配置寄存器(GPIOx_CRL，GPIOx_CRH)
- 两个32位数据寄存器(GPIOx_IDR和GPIOx_ODR)
- 一个32位置位/复位寄存器(GPIOx_BSRR)
- 一个16位复位寄存器(GPIOx_BRR)
- 一个32位锁定寄存器(GPIOx_LCKR)。

大家如果想要了解每个寄存器的详细使用方法，可以参考《STM32 中文参考手册 V10》P105~P129。

#### 1.2.1 配置寄存器(GPIOx_CRL，GPIOx_CRH)

CRL 和 CRH 控制着每个 IO 口的**模式**及**输出速率**。

## 2. 硬件设计

本实验用到的硬件只有 LED（DS0 和 DS1）。其电路在 ALIENTEK MiniSTM32 开发板上默认
是已经连接好了的。DS0 接 PA8，DS1 接 PD2。所以在硬件上不需要动任何东西。其连接原理如下：

![LED连接]

## 3. 软件设计

### 3.1 LED驱动

#### 3.1.1 led.c文件

```c
# include "led.h"
# include "stm32f10x.h"

/**
  * @brief LED驱动函数
  * @param NONE
  * @retval NONE
  * @details LED0(红色)-->PA.8    LED1(绿色)-->PD.2
  *          驱动初始化后电平拉低
  */
void LED_Init(void)
{
  GPIO_InitTypeDef  GPIO_InitStructure0,GPIO_InitStructure1;    //定义结构体变量
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);  //使能PA端口时钟
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);  //使能PD端口时钟

  GPIO_InitStructure0.GPIO_Pin = GPIO_Pin_8;          //LED0-->PA.8 端口配置
  GPIO_InitStructure0.GPIO_Mode = GPIO_Mode_Out_PP;   //推挽输出
  GPIO_InitStructure0.GPIO_Speed = GPIO_Speed_50MHz;  //IO口速度为50MHz
  GPIO_Init(GPIOA, &GPIO_InitStructure0);             //根据设定参数初始化GPIOA.8

  GPIO_InitStructure1.GPIO_Pin = GPIO_Pin_2;          //LED1-->PD.2 端口配置
  GPIO_InitStructure1.GPIO_Mode = GPIO_Mode_Out_PP;   //推挽输出
  GPIO_InitStructure1.GPIO_Speed = GPIO_Speed_50MHz;  //IO口速度为50MHz
  GPIO_Init(GPIOD, &GPIO_InitStructure1);             //根据设定参数初始化GPIOD.2

  GPIO_ResetBits(GPIOA,GPIO_Pin_8);                     //PA.8 输出低
  GPIO_ResetBits(GPIOD,GPIO_Pin_2);                     //PD.2 输出低
}

void RED_ON(void)
{
  GPIO_ResetBits(GPIOA,GPIO_Pin_8);
}

void RED_OFF(void)
{
  GPIO_SetBits(GPIOA,GPIO_Pin_8);
}

void GREEN_ON(void)
{
  GPIO_ResetBits(GPIOD,GPIO_Pin_2);
}

void GREEN_OFF(void)
{
  GPIO_SetBits(GPIOD,GPIO_Pin_2);
}
```

因为 GPIOA 和 GPIOD 的 IO 口的初始化参数都是设置在结构体变量 `GPIO_InitStructure` 中，因为两个 IO 口的模式和速度都一样，所以我们只用初始化一次，在GPIOD.2 的初始化的时候就不需要再重复初始化速度和模式了。

```C

void LED_Init(void)
{
  GPIO_InitTypeDef  GPIO_InitStructure;              //定义结构体变量
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOD, ENABLE);  //使能PA,PD端口时钟

  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;          //LED0-->PA.8 端口配置
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   //推挽输出
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  //IO口速度为50MHz
  GPIO_Init(GPIOA, &GPIO_InitStructure);             //根据设定参数初始化GPIOA.8
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;           //LED1-->PD.2 端口配置.
  GPIO_Init(GPIOD, &GPIO_InitStructure);              //根据设定参数初始化GPIOD.2

  GPIO_ResetBits(GPIOA,GPIO_Pin_8);                     //PA.8 输出低
  GPIO_ResetBits(GPIOD,GPIO_Pin_2);                     //PD.2 输出低
}
```

#### 3.1.2 led.h文件

```c
#ifndef __LED_H
#define __LED_H

void LED_Init(void);
void RED_ON(void);
void RED_OFF(void);
void GREEN_ON(void);
void GREEN_OFF(void);

#endif

```

#### 3.1.3 main文件

```c
# include "led.h"
# include "delay.h"

int main(void)
{
  delay_init();
  LED_Init();
  while(1)
  {
    RED_ON();
    delay_ms(500);
    GREEN_ON();
    delay_ms(500);
    RED_OFF();
    delay_ms(500);
    GREEN_OFF();
    delay_ms(500);
  }
}
```

[LED连接]: <./image/Image_177.jpg> "LED连接"

[寄存器]: <../../基础概念/寄存器.md>
