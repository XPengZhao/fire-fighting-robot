# stm32 定时器中断

## 1. stm32 TIM3时钟及中断时间计算

系统初始化的时候在默认的系统初始化函数 SystemInit 函数里面已经初始化 APB1 的时钟为 2 分频，所以 APB1 的时钟为 36M，而从 STM32 的内部时钟树图得知：当 APB1 的时钟分频数为 1 的时候，TIM2~7 的时钟为 APB1 的时钟，而如果 APB1 的时钟分频数不为 1，那么 TIM2~7 的时钟频率将为 APB1 时钟的两倍。因此，TIM3 的时钟为 72M，再根据我们设计的 arr 和 psc 的值，就可以计算中断时间了。计算公式如下：
> Tout= ((arr+1)*(psc+1))/Tclk;
> Tclk：TIM3 的输入时钟频率（单位为 Mhz）。
> Tout：TIM3 溢出时间（单位为 us）。

## 3. 软件设计

定时器中断实现步骤:

1. 能定时器时钟。
  `RCC_APB1PeriphClockCmd();`
2. 初始化定时器，配置ARR,PSC。
  `TIM_TimeBaseInit();`
3. 开启定时器中断，配置NVIC。
  `void TIM_ITConfig();NVIC_Init();`
4. 使能定时器。
  `TIM_Cmd();`
5. 编写中断服务函数。
  `TIMx_IRQHandler();`






### 3.1 定时器中断驱动

在库函数中，定时器的初始化参数是通过初始化函数 TIM_TimeBaseInit 实现的：
`void TIM_TimeBaseInit(TIM_TypeDef *TIMx,TIM_TimeBaseInitTypeDef *TIM_TimeBaseInitStruct);`

第一个参数是确定是哪个定时器，这个比较容易理解。第二个参数是定时器初始化参数结构体指针，结构体类型为 TIM_TimeBaseInitTypeDef，下面我们看看这个结构体的定义： 

```c
typedef struct
{
  uint16_t TIM_Prescaler;
  uint16_t TIM_CounterMode;
  uint16_t TIM_Period;
  uint16_t TIM_ClockDivision;
  uint8_t TIM_RepetitionCounter;
}TIM_TimeBaseInitTypeDef;
```

这个结构体一共有 5 个成员变量，要说明的是，对于通用定时器只有前面四个参数有用，最后一个参数 TIM_RepetitionCounter 是高级定时器才有用的。

* 第一个参数 TIM_Prescaler 是用来设置分频系数的。
* 第二个参数 TIM_CounterMode 是用来设置计数方式，可以设置为向上计数，向下计数方式还有中央对齐计数方式，比较常用的是向上计数模式 TIM_CounterMode_Up 和向下计数模式 TIM_CounterMode_Down。
* 第三个参数是设置自动重载计数周期值。
* 第四个参数是用来设置时钟分频因子。

#### 3.1.1 time.c文件

```c
void TIM3_Int_Init(u16 arr,u16 psc)
{
    TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
    NVIC_InitTypeDef NVIC_InitStructure;

    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //时钟使能

    TIM_TimeBaseStructure.TIM_Period = arr;   //设置在下一个更新事件装入活动的自动重装载寄存器周期的值,计数到5000为500ms
    TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值  10Khz的计数频率
    TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim
    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位

    TIM_ITConfig(TIM3,TIM_IT_Update,ENABLE);         //使能更新中断
    NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;  //TIM3中断
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;  //先占优先级0级
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;  //从优先级3级
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能
    NVIC_Init(&NVIC_InitStructure);  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器

  TIM_Cmd(TIM3, ENABLE);  //使能TIMx外设
}


/**
  * @brief 中断服务函数
  */
void TIM3_IRQHandler(void)   //TIM3中断
{
  if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) //检查指定的TIM中断发生与否:TIM 中断源 
    {
    TIM_ClearITPendingBit(TIM3, TIM_IT_Update  );  //清除TIMx的中断待处理位:TIM 中断源 
    TOGGLE_RED();
    }
}

```

#### 3.1.2 time.h文件

```c
#ifndef __TIMER_H
#define __TIMER_H
#include "sys.h"
void TIM3_Int_Init(u16 arr,u16 psc);
```

### 3.2 led驱动

#### 3.2.1 led.c文件

#### 3.2.2 led.h文件

### 3.3 主函数部分 main.c

```c
delay_init();
#include "led.h"
#include "delay.h"
#include "sys.h"
#include "timer.h"
delay_init();       //延时函数初始化
NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  // 设置中断优先级分组2
LED_Init();              //初始化与LED连接的硬件接口
TIM3_Int_Init(4999,7199);//10Khz的计数频率，计数到5000为500ms
while(1)
{

}
```
